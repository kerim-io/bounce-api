<style>
#chat-panel{position:fixed;bottom:0;left:0;right:0;z-index:400;display:none;flex-direction:column;pointer-events:none;transition:none}
#feed-sheet{pointer-events:auto;background:rgba(17,17,17,.96);backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);border-top-left-radius:16px;border-top-right-radius:16px;display:flex;flex-direction:column;overflow:hidden;will-change:transform,height;box-shadow:0 -2px 20px rgba(0,0,0,.5)}
#feed-handle-bar{padding:10px 0 6px;display:flex;justify-content:center;cursor:grab;touch-action:none;flex-shrink:0}
#feed-handle-bar .handle{width:36px;height:4px;border-radius:2px;background:#555}
#feed-header{display:flex;align-items:center;justify-content:space-between;padding:0 16px 8px;flex-shrink:0;cursor:grab;touch-action:none}
#feed-header .feed-title{font-family:system-ui,-apple-system,sans-serif;font-size:15px;font-weight:700;color:#fff;letter-spacing:.3px}
#feed-header .feed-badge{background:#4a9eff;color:#fff;font-size:10px;border-radius:50%;min-width:18px;height:18px;display:none;align-items:center;justify-content:center;font-weight:700;padding:0 5px;font-family:system-ui,-apple-system,sans-serif}
#feed-messages{flex:1;overflow-y:auto;padding:4px 16px;display:flex;flex-direction:column;gap:4px;-webkit-overflow-scrolling:touch;min-height:0;cursor:grab}
#feed-input-bar{display:flex;padding:8px 12px;gap:8px;border-top:1px solid #222;flex-shrink:0}
#feed-input{flex:1;background:#1a1a1a;border:1px solid #2a2a2a;border-radius:20px;padding:9px 14px;color:#fff;font-size:14px;outline:none;font-family:system-ui,-apple-system,sans-serif}
#feed-input:focus{border-color:#4a9eff}
#feed-input::placeholder{color:#555}
#feed-send{background:#4a9eff;color:#fff;border:none;border-radius:50%;width:36px;height:36px;font-size:15px;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:opacity .2s;font-family:system-ui,-apple-system,sans-serif}
#feed-send:active{opacity:.7}
</style>

<div id="chat-panel">
  <div id="feed-sheet">
    <div id="feed-handle-bar"><div class="handle"></div></div>
    <div id="feed-header">
      <div style="display:flex;align-items:center;gap:8px">
        <span class="feed-title">Live Feed</span>
        <span class="feed-badge" id="feed-badge">0</span>
      </div>
    </div>
    <div id="feed-messages"></div>
    <div id="feed-input-bar">
      <input id="feed-input" type="text" placeholder="Say something..." maxlength="500" autocomplete="off">
      <button id="feed-send" onclick="sendChat()">&#9654;</button>
    </div>
  </div>
</div>

{{FEED_ITEM}}

<script>
// Sheet snap heights (fraction of viewport)
var SNAP_MIN = 0.22;   // collapsed — just header + input
var SNAP_MED = 0.42;   // medium
var SNAP_FULL = 0.85;  // full height
var feedSnap = 'med';   // current snap: 'min', 'med', 'full'
var unreadCount = 0;

var sheetEl, handleEl;
var dragging = false;
var dragStartY = 0;
var dragStartH = 0;

function initFeedSheet() {
  sheetEl = document.getElementById('feed-sheet');
  handleEl = document.getElementById('feed-handle-bar');
  var headerEl = document.getElementById('feed-header');
  var messagesEl = document.getElementById('feed-messages');
  var inputBar = document.getElementById('feed-input-bar');

  // Touch events — handle + header always drag the sheet
  handleEl.addEventListener('touchstart', onDragStart, { passive: false });
  headerEl.addEventListener('touchstart', onDragStart, { passive: false });
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);

  // Mouse events (desktop)
  handleEl.addEventListener('mousedown', onDragStart);
  headerEl.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);

  // Messages area: smart drag vs scroll
  messagesEl.addEventListener('touchstart', onContentTouchStart, { passive: true });
  messagesEl.addEventListener('touchmove', onContentTouchMove, { passive: false });
  messagesEl.addEventListener('touchend', onContentTouchEnd);

  // Restore persisted chat
  restoreChat();

  // App users start collapsed (they came for the map), guests start at medium
  snapTo(IS_APP_USER ? 'min' : 'med', false);
}

function getSnapPx(snap) {
  var vh = window.innerHeight;
  if (snap === 'min') return Math.round(vh * SNAP_MIN);
  if (snap === 'full') return Math.round(vh * SNAP_FULL);
  return Math.round(vh * SNAP_MED);
}

function snapTo(snap, animate) {
  feedSnap = snap;
  var h = getSnapPx(snap);
  if (animate !== false) {
    sheetEl.style.transition = 'height .3s cubic-bezier(.2,.9,.3,1)';
    setTimeout(function() { sheetEl.style.transition = 'none'; }, 320);
  }
  sheetEl.style.height = h + 'px';
  if (snap !== 'min') scrollFeed();
}

var dragLastY = 0;
var dragLastTime = 0;
var dragVelocity = 0; // px/ms, positive = dragging up

function onDragStart(e) {
  dragging = true;
  var y = e.touches ? e.touches[0].clientY : e.clientY;
  dragStartY = y;
  dragLastY = y;
  dragLastTime = Date.now();
  dragVelocity = 0;
  dragStartH = sheetEl.offsetHeight;
  sheetEl.style.transition = 'none';
  if (e.cancelable) e.preventDefault();
}

function onDragMove(e) {
  if (!dragging) return;
  var clientY = e.touches ? e.touches[0].clientY : e.clientY;
  var now = Date.now();
  var dt = now - dragLastTime;
  if (dt > 0) {
    dragVelocity = (dragLastY - clientY) / dt; // positive = up
  }
  dragLastY = clientY;
  dragLastTime = now;
  var dy = dragStartY - clientY;
  var newH = Math.max(getSnapPx('min'), Math.min(getSnapPx('full'), dragStartH + dy));
  sheetEl.style.height = newH + 'px';
  if (e.cancelable) e.preventDefault();
}

function onDragEnd(e) {
  if (!dragging) return;
  dragging = false;
  var h = sheetEl.offsetHeight;
  var vh = window.innerHeight;
  var frac = h / vh;

  // Velocity-based: a fast flick overrides position-based snap
  var FLICK_THRESHOLD = 0.4; // px/ms
  if (dragVelocity > FLICK_THRESHOLD) {
    // Flicked up — go to next detent above current
    if (frac < SNAP_MED) { snapTo('med', true); }
    else { snapTo('full', true); }
    return;
  }
  if (dragVelocity < -FLICK_THRESHOLD) {
    // Flicked down — go to next detent below current
    if (frac > SNAP_MED) { snapTo('med', true); }
    else { snapTo('min', true); }
    return;
  }

  // Position-based: snap to nearest detent
  var midLow = (SNAP_MIN + SNAP_MED) / 2;
  var midHigh = (SNAP_MED + SNAP_FULL) / 2;

  if (frac < midLow) {
    snapTo('min', true);
  } else if (frac < midHigh) {
    snapTo('med', true);
  } else {
    snapTo('full', true);
  }
}

// Content area smart drag: drag sheet when not at full detent,
// scroll normally at full detent (with pull-down-at-top to collapse)
var contentDragging = false;
var contentStartY = 0;
var contentLocked = false; // locked to scroll (don't drag sheet)
var DRAG_DEAD_ZONE = 8; // px before deciding drag vs scroll
var contentDecided = false;

function onContentTouchStart(e) {
  contentDragging = false;
  contentLocked = false;
  contentDecided = false;
  contentStartY = e.touches[0].clientY;
}

function onContentTouchMove(e) {
  if (contentLocked) return; // normal scroll mode
  var messagesEl = document.getElementById('feed-messages');
  var clientY = e.touches[0].clientY;
  var dy = clientY - contentStartY; // positive = finger down
  var absDy = Math.abs(dy);

  // Wait for dead zone before deciding
  if (!contentDecided && absDy < DRAG_DEAD_ZONE) return;
  contentDecided = true;

  // NOT at full detent → all vertical movement drags the sheet
  if (feedSnap !== 'full' && !contentDragging && !contentLocked) {
    contentDragging = true;
    dragging = true;
    dragStartY = clientY;
    dragLastY = clientY;
    dragLastTime = Date.now();
    dragVelocity = 0;
    dragStartH = sheetEl.offsetHeight;
    sheetEl.style.transition = 'none';
  }

  // AT full detent → only hijack to sheet drag when at scroll top dragging down
  if (feedSnap === 'full' && !contentDragging) {
    if (dy > 0 && messagesEl.scrollTop <= 0) {
      contentDragging = true;
      dragging = true;
      dragStartY = clientY;
      dragLastY = clientY;
      dragLastTime = Date.now();
      dragVelocity = 0;
      dragStartH = sheetEl.offsetHeight;
      sheetEl.style.transition = 'none';
    } else {
      contentLocked = true; // normal scroll
      return;
    }
  }

  if (contentDragging) {
    if (e.cancelable) e.preventDefault();
    onDragMove(e);
  }
}

function onContentTouchEnd(e) {
  if (contentDragging) {
    contentDragging = false;
    onDragEnd(e);
  }
}

// --- Chat persistence via localStorage ---
var CHAT_STORAGE_KEY = 'bounce_chat_' + SHARE_TOKEN;
var MAX_STORED_MSGS = 200;

function saveChatMsg(obj) {
  try {
    var msgs = JSON.parse(localStorage.getItem(CHAT_STORAGE_KEY) || '[]');
    msgs.push(obj);
    if (msgs.length > MAX_STORED_MSGS) msgs = msgs.slice(-MAX_STORED_MSGS);
    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(msgs));
  } catch(e) {}
}

function restoreChat() {
  try {
    var msgs = JSON.parse(localStorage.getItem(CHAT_STORAGE_KEY) || '[]');
    msgs.forEach(function(m) {
      if (m.system) {
        renderSystemMsg(m.text);
      } else {
        renderChatMsg(m.sender, m.text, m.isAi, m.isSelf, m.timestamp, m.pic);
      }
    });
  } catch(e) {}
}

function updateFeedBadge() {
  var badge = document.getElementById('feed-badge');
  if (unreadCount > 0) {
    badge.textContent = unreadCount > 9 ? '9+' : unreadCount;
    badge.style.display = 'flex';
  } else {
    badge.style.display = 'none';
  }
}

function scrollFeed() {
  var el = document.getElementById('feed-messages');
  setTimeout(function() { el.scrollTop = el.scrollHeight; }, 50);
}

function escapeHtml(str) {
  var d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function appendChatMsg(sender, text, isAi, isSelf, timestamp, pic) {
  renderChatMsg(sender, text, isAi, isSelf, timestamp, pic);
  saveChatMsg({ sender: sender, text: text, isAi: isAi, isSelf: isSelf, timestamp: timestamp, pic: pic || null });

  // If collapsed, bump unread
  if (feedSnap === 'min') {
    unreadCount++;
    updateFeedBadge();
  }
}

function appendSystemMsg(text) {
  renderSystemMsg(text);
  saveChatMsg({ system: true, text: text });
}

function sendChat() {
  var input = document.getElementById('feed-input');
  var text = input.value.trim();
  if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify({ type: 'chat_message', text: text }));
  var selfPic = IS_APP_USER ? APP_USER_PIC : null;
  appendChatMsg(myName, text, false, true, Date.now() / 1000, selfPic);
  input.value = '';
}

document.addEventListener('keydown', function(e) {
  if (e.target.id === 'feed-input' && e.key === 'Enter') {
    sendChat();
  }
});

// Init sheet on load
initFeedSheet();

// Monkey-patch handleMessage to intercept chat-related messages
var _origHandleMessage = handleMessage;
handleMessage = function(msg) {
  _origHandleMessage(msg);

  if (msg.type === 'chat_message') {
    // Detect if this message is from ourselves
    var isSelf = false;
    if (msg.is_ai) {
      isSelf = false;
    } else if (IS_APP_USER && msg.user_id === APP_USER_ID) {
      isSelf = true;
    } else if (!IS_APP_USER && msg.guest_id === myGuestId) {
      isSelf = true;
    }
    if (isSelf) return; // already appended locally on send
    var pic = msg.profile_picture || null;
    appendChatMsg(msg.sender, msg.text, msg.is_ai, false, msg.timestamp, pic);
  }
  if (msg.type === 'chat_history') {
    // Server sends full history — replace local cache and re-render
    document.getElementById('feed-messages').innerHTML = '';
    try { localStorage.removeItem(CHAT_STORAGE_KEY); } catch(e) {}
    (msg.messages || []).forEach(function(m) {
      appendChatMsg(m.sender, m.text, m.is_ai, false, m.timestamp);
    });
  }
  if (msg.type === 'guest_joined' && msg.guest_id !== myGuestId) {
    appendSystemMsg(msg.display_name + ' joined the bounce');
  }
  if (msg.type === 'guest_left' && msg.guest_id !== myGuestId) {
    appendSystemMsg(msg.display_name + ' left');
  }
};
</script>
